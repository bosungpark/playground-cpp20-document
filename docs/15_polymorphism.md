Polymorphism
=
c++에서 다형성은 언제나 멤버함수를 호출하기 위해 레퍼런스나 포인터를 사용하는 것과 관련이 있다.

다형성은 공통의 상위 클래스를 가지는 경우에 작동한다. 

**Using a Base Class Pointer**
하위 모델은 베이스의 특수한 형태이다. 따라서 베이스 타입의 포인터를 사용해 하위 모델의 주소를 저장하는 것은 합리적이다. 반대는 적용되지 않는다. 하위 모델은 언제나 베이스 모델의 객체 들을 가지고 있다. 하지만 반대로 베이스 모델은 하위 모델의 객체를 일부만 가지고 있다. 

**스테틱 타입, 다이나믹 타입**
스테틱 타입: 부모 객체이 부모 객체를 정직하게 가리키는 포인터가 예시. 컴파일 시점에 정해지는 타입.
다이나믹 타입: 부모 타입의 포인터가 자식 객체를 가리키는 경우가 예시. 런타임에 정해지는 타입.

스테틱한 함수의 호출은 포인터의 타입을 통해 결정이난다. (객체의 타입이 아니다!)

Virtual Functions
=
클래스는 polymorphic하게 작성한다는 것은 적어도 하나의 Virtual Function을 정의한다는 것이다.
베이스 클래스에서 함수를 virtual하게 선언한다면, 컴파일러에 해당 함수는 동적인 바인딩을 하겠다고 선언하는 것이다.
이를 이용하면 자식 클래스에서 함수를 호출할 때, 동적으로 사용할 수 있다.

Requirements for Virtual Function Operation
=
Virtual Function은 베이스 클래스와 완전히 같은 형식을 가져야 한다...!! (당연하지만...!!)
헷갈랄거 같은면 오버라이드 표시를 해주자!

Polymorphic
=
그냥 어레이에 추가하면 object slicing(파생 클래스의 속성이 날아가고 기본 클래스의 속성만 남게 되는 것)이 발생한다.
벡터는 객체를 저장할 공간이 없기 때문에 파생클래스의 객체는 기본클래스로 변환된다. 
다형성을 사용하기 위해서는 포인터나 레퍼런스를 사용해야 한다.

destructor 역시 만일 동적으로 설정하지 않으면, 기본 클래스를 기준으로 호출되기 때문에 문제가 생길 수 있다.

